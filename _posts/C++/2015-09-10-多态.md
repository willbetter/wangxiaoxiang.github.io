---
layout:     post
title:      "多态"
date:       2015-09-10 15:36:00
author:     "GoTT"
header-img: "img/post-bg-2015.jpg"
category : [多态]
tags : C++
---

# 多态

## 介绍(来源于网络)

多态性(polymorphism)是面向对象程序设计的一个重要特征。如果一种语言只支持类而不支持多态，是不能被称为面向对象语言的，只能说是基于对象的，如Ada、VB就属此类。C++支持多态性，在C++程序设计中能够实现多态性。利用多态性可以设计和实现一个易于扩展的系统。

顾名思义，多态的意思是一个事物有多种形态。多态性的英文单词polymorphism来源于希腊词根poly(意为“很多”)和morph(意为“形态”）。在C ++程序设计中，多态性是指具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性的：向不同的对象发送同一个消息， 不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。

其实，我们已经多次接触过多态性的现象，例如函数的重载、运算符重载都是多态现象。只是那时没有用到多态性这一专门术语而已。例如，使用运算符“+”使两个数值相加，就是发送一个消息，它要调用operator +函数。实际上，整型、单精度型、双精度型的加法操作过程是互不相同的，是由不同内容的函数实现的。显然，它们以不同的行为或方法来响应同一消息。

>在现实生活中可以看到许多多态性的例子。如学校校长向社会发布一个消息：9月1日新学年开学。不同的对象会作出不同的响应：学生要准备好课本准时到校上课；家长要筹集学费；教师要备好课；后勤部门要准备好教室、宿舍和食堂……由于事先对各种人的任务已作了规定，因此，在得到同一个消息时，各种人都知道自己应当怎么做，这就是 多态性。可以设想，如果不利用多态性，那么校长就要分别给学生、家长、教师、后勤部门等许多不同的对象分别发通知，分别具体规定每一种人接到通知后应该怎么做。显然这是一件十分复杂而细致的工作。一人包揽一切，吃力还不讨好。现在，利用了多态性机制，校长在发布消息时，不必一一具体考虑不同类型人员是怎样执行的。至于各类人员在接到消息后应气做什么，并不是临时决定的，而是学校的工作机制事先安排决定好的。校长只需不断发布各种消息，各种人员就会按预定方案有条不紊地工作。

同样，在C++程序设计中，在不同的类中定义了其响应消息的方法，那么使用这些类 时，不必考虑它们是什么类型，只要发布消息即可。正如在使用运算符“ ”时不必考虑相加的数值是整型、单精度型还是双精度型，直接使用“+”，不论哪类数值都能实现相加。可以说这是以不变应万变的方法，不论对象千变万化，用户都是用同一形式的信息去调用它们，使它们根据事先的安排作出反应。

从系统实现的角度看，多态性分为两类：静态多态性和动态多态性。以前学过的函数重载和运算符重载实现的多态性属于静态多态性，在程序编译时系统就能决定调用的是哪个函数，因此静态多态性又称编译时的多态性。静态多态性是通过函数的重载实现的（运算符重载实质上也是函数重载）。动态多态性是在程序运行过程中才动态地确定操作所针对的对象。它又称运行时的多态性。动态多态性是通过虚函数（Virtual fiinction)实现的。

## 一个例子

你有一个基类`Animal`，基类中有一个公开方法`howl()`。又有子类`Wofl`、`Cat`，子类中重写了父类中的公开方法`howl()`。现有工具方法`AnimalHowl(const Animal& animal)`，当在工具方法中调用`animal.howl()`时(传入`Wofl`、`Cat`类对象)却是调用了父类中的方法，参考([Polymorphism01](https://github.com/wangxiaoxiang/Practice/blob/master/CPP/Inheritance%20and%20polymorphism/Polymorphism01.cpp))。


## 虚函数

这样就出现一个问题，不同动物的嚎叫声也不同，解决这个问题就需要使用虚函数，使用方式是在基类的方法前加`virtual`关键字。如:`virtual void howl() const`。

虚函数的使用方法是：

* 在基类用virtual声明成员函数为虚函数。这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用。在类外定义虚函数时，不必再加virtual。

* 在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体。

* C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此在派生类重新声明该虚函数时，可以加virtual，也可以不加，但习惯上一般在每一层声明该函数时都加virtual，使程序更加清晰。如果在派生类中没有对基类的虚函数重新定义，则派生类简单地继承其直接基类的虚函数。

* 定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数。通过虚函数与指向基类对象的指针变量的配合使用，就能方便地调用同一类族中不同类的同名函数，只要先用基类指针指向即可。如果指针不断地指向同一类族中不同类的对象，就能不断地调用这些对象中的同名函数。这就如同前面说的，不断地告诉出租车司机要去的目的地，然后司机把你送到你要去的地方。

>需要说明；有时在基类中定义的非虚函数会在派生类中被重新定义，如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；如果用派生类指针调用该成员函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为(使用的是不同类型的指针)，没有用到虚函数的功能。

## 虚函数表

当类中有虚函数时，C++就会给类中添加`虚函数表`指针，有点像是函数指针数组。

```
#include <iostream>
using namespace std;

void wxx_swap(int* a,int *b)
{
    int x = *a;
    *a  = *b;
    *b = x;
}

void wxx_swap_pro(int* a,int *b)
{
    int x = *a;
    *a  = *b;
    *b = x;
    cout<<*a<<","<<*b<<endl;
}

typedef void(*wxx_swap_ptr)(int*,int*);

int main(int argc, const char * argv[]) {
    // insert code here...
    wxx_swap_ptr p1 = &wxx_swap;
    wxx_swap_ptr p2 = &wxx_swap_pro;
    int a = 10;
    int b = 5;
    p1(&a,&b);
    cout<<a<<","<<b<<endl;
    p2(&a,&b);
    return 0;
}
```

## 纯虚函数和抽象类

在C++中，含有纯虚拟函数的类称为抽象类，它不能生成对象，看起来像Java中的接口(Objective-C中的协议)。形式:

```
class 类名 {
  virtual 迒回类型 凼数名 (形参表) = 0;
};
```

抽象类的子类如果不对基类中的全部纯虚凼数提供 有效的覆盖,那举该子类就也是抽象类。全部由纯虚凼数构成的抽象类称为纯抽象类或接口。参考:
[Polymorphism03](https://github.com/wangxiaoxiang/Practice/blob/master/CPP/Inheritance%20and%20polymorphism/Polymorphism03.cpp)、纯虚函数->[Polymorphism04](https://github.com/wangxiaoxiang/Practice/blob/master/CPP/Inheritance%20and%20polymorphism/Polymorphism04.cpp)

## 运行时类型识别

### RTTI介绍

RTTI（Run-Time Type Information)，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型。参考:[typeinfo](http://www.cplusplus.com/reference/typeinfo/type_info/)

```
//摘自https://github.com/wangxiaoxiang/Practice/blob/master/CPP/Inheritance%20and%20polymorphism/Polymorphism04.cpp
void show_plane(Plane* plane)
{
    plane->slide();
    plane->take_of();
    if (Fighter* fighter = dynamic_cast<Fighter*>(plane)) {
      fighter->fire();
    }
    plane->landing();
}

```
